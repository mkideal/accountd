// NOTE: AUTO-GENERATED by midc, DON'T edit!!

package model

import (
	"fmt"

	"github.com/mkideal/pkg/storage"
	"github.com/mkideal/pkg/typeconv"
	"gopkg.in/redis.v5"
)

var (
	_ = fmt.Printf
	_ = storage.Unused
	_ = typeconv.Unused
	_ = redis.Nil
)

// Table

// 访问客户端
type Client struct {
	Id          string `xorm:"pk VARCHAR(32)"` // oauth 客户端唯一Id
	Secret      string `xorm:"VARCHAR(64)"`    // 密码
	Name        string `xorm:"VARCHAR(64)"`    // 应用名称
	Description string `xorm:"TEXT"`           // 应用描述
	Logo        string `xorm:"VARCHAR(256)"`   // Logo 地址
	Scope       string `xorm:"TEXT"`           // 授权范围
	HomepageUrl string `xorm:"VARCHAR(256)"`   // 主页地址
	CallbackUrl string `xorm:"VARCHAR(256)"`   // 回调地址

}

func NewClient() *Client {
	return &Client{}
}

func (Client) Meta() ClientMeta             { return clientMetaVar }
func (Client) TableMeta() storage.TableMeta { return clientMetaVar }
func (x Client) Key() interface{}           { return x.Id }
func (x *Client) SetKey(value string) error {
	x.Id = value
	return nil
}

func (x Client) GetField(field string) (interface{}, bool) {
	switch field {
	case clientMetaVar.F_secret:
		return x.Secret, true
	case clientMetaVar.F_name:
		return x.Name, true
	case clientMetaVar.F_description:
		return x.Description, true
	case clientMetaVar.F_logo:
		return x.Logo, true
	case clientMetaVar.F_scope:
		return x.Scope, true
	case clientMetaVar.F_homepage_url:
		return x.HomepageUrl, true
	case clientMetaVar.F_callback_url:
		return x.CallbackUrl, true
	}
	return nil, false
}

func (x *Client) SetField(field, value string) error {
	switch field {
	case clientMetaVar.F_secret:
		x.Secret = value
	case clientMetaVar.F_name:
		x.Name = value
	case clientMetaVar.F_description:
		x.Description = value
	case clientMetaVar.F_logo:
		x.Logo = value
	case clientMetaVar.F_scope:
		x.Scope = value
	case clientMetaVar.F_homepage_url:
		x.HomepageUrl = value
	case clientMetaVar.F_callback_url:
		x.CallbackUrl = value
	}
	return nil
}

// Meta
type ClientMeta struct {
	F_secret       string
	F_name         string
	F_description  string
	F_logo         string
	F_scope        string
	F_homepage_url string
	F_callback_url string
}

func (ClientMeta) Name() string     { return "client" }
func (ClientMeta) Key() string      { return "id" }
func (ClientMeta) Fields() []string { return _client_fields }

var clientMetaVar = ClientMeta{
	F_secret:       "secret",
	F_name:         "name",
	F_description:  "description",
	F_logo:         "logo",
	F_scope:        "scope",
	F_homepage_url: "homepage_url",
	F_callback_url: "callback_url",
}

var _client_fields = []string{
	clientMetaVar.F_secret,
	clientMetaVar.F_name,
	clientMetaVar.F_description,
	clientMetaVar.F_logo,
	clientMetaVar.F_scope,
	clientMetaVar.F_homepage_url,
	clientMetaVar.F_callback_url,
}

// Slice
type ClientSlice []Client

func NewClientSlice(cap int) *ClientSlice {
	s := ClientSlice(make([]Client, 0, cap))
	return &s
}

func (s ClientSlice) TableMeta() storage.TableMeta { return clientMetaVar }
func (s ClientSlice) Len() int                     { return len(s) }
func (s *ClientSlice) Slice() []Client             { return []Client(*s) }

func (s *ClientSlice) New(table string, index int, key string) (storage.Table, error) {
	for len(*s) <= index {
		*s = append(*s, Client{})
	}
	x := &((*s)[index])
	err := x.SetKey(key)
	return x, err
}

// View
type ClientView struct {
	Client
}

type ClientViewSlice []ClientView

func NewClientViewSlice(cap int) *ClientViewSlice {
	s := ClientViewSlice(make([]ClientView, 0, cap))
	return &s
}

func (s ClientViewSlice) TableMeta() storage.TableMeta { return clientMetaVar }
func (s ClientViewSlice) Len() int                     { return len(s) }
func (s *ClientViewSlice) Slice() []ClientView         { return []ClientView(*s) }

func (s *ClientViewSlice) New(table string, index int, key string) (storage.Table, error) {
	if table == "client" {
		for len(*s) <= index {
			x := Client{}
			*s = append(*s, ClientView{Client: x})
		}
		x := &((*s)[index].Client)
		err := x.SetKey(key)
		return x, err
	}
	v := &((*s)[index])
	for t, x := range v.tables() {
		if t == table {
			err := x.SetKey(key)
			return x, err
		}
	}
	return nil, storage.ErrTableNotFoundInView
}

var (
	ClientViewVar  = ClientView{}
	clientViewRefs = map[string]storage.View{}
)

func (ClientView) TableMeta() storage.TableMeta  { return clientMetaVar }
func (ClientView) Fields() storage.FieldList     { return storage.FieldSlice(clientMetaVar.Fields()) }
func (ClientView) Refs() map[string]storage.View { return clientViewRefs }
func (view *ClientView) tables() map[string]storage.Table {
	m := make(map[string]storage.Table)
	m["client"] = &view.Client
	return m
}
